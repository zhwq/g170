## 不同GC和堆内存

### GC 大致分类

- 串行 `-XX:SerialGC`
- 并行 `-XX:ParallelGC`
- 并发 CMS `-XX:UseConcMarkSweepGC`
- G1 `-XX:G1GC`

Young区和Old区需要采用不通的垃圾回收算法, 从JDK1.3开始自今, GC的演进体系大致分为4个: 串行 --> 并行 --> 并发 --> G1

#### 串行GC

采用 `stop-the-world`的方式进行收集, 适合堆内存不高、单核/双核CPU场合

#### 并行GC
以关注吞吐量为目标, server模式下默认采用
同 串行GC 以 `stop-the-word`的方式, 只是应用线程暂停时, 并行地进行垃圾收集。
其中:
年轻代采用`复制算法`
老年代采用`标记、整理`
另外:
在回收的同时进行内存的压缩
吞吐量指标只要体现在年轻代的`Parallel Scavenge收集器`, 可通过以下2个参数:
- `-XX:MaxGCPauseMills`
- `-XX:GCTimeRadio`
调整新生代空间大小, 来降低触发GC的频率

应用场景:
在吞吐量要求远远高于延迟要求

#### 并发GC `CMS(old区)`
CMS以关注延迟为目标, 是正对Old区的垃圾回收
收集周期:
- 初始标记 `以stw的方式标记所以的根对象` `优化为多线程执行`
- 并发标记 `同应用程序并行, 标记出跟对象的可达路径`
- 重新标记 `优化为多线程执行`
- 并发清除
应用场景:
适合堆内存大、 多核的服务器端环境
缺陷:
- 标记-清理不是标记-整理, 因此会产生**内存碎片**, 随着时间的推移, Old区会被耗尽或产生无法分配大对象的情况 然后通过底层的担保机制(**CMS有串行回收兜底**)进行一次FUll GC 并进行内存压缩
- 标记和清理都是通过应用现场并发进行, 会增加**堆内存的占用**, 在内存不够用的情况下触发1中情况 进行串行回收

#### G1 `Garbage First`
堆内存与其他收集器有很大差别, **G1收集器将堆划分为多个大小相等的独立区域(Region)**, 此时内存模型虽然有新生代和年轻代的概念, 但是新生代和年轻代不再是**物理隔离**的, 而是一部分Region(可不连续)的集合

- Region分区大小一样, 值在1-32M, =2^x, 可通过`-XX:G1HeapRegionSize`设置Region大小
- 一个Region有2个状态: 空闲、 标记为新生代、 标记为老年代
- 整体采用`标记-整理算法`, 不会产生内存碎片
- G1采用`筛选回收`的策略 优先回收垃圾多的Region区

回收步骤:
- 初始标记
- 并发标记
- 最终标记
- 筛选回收

#### ZGC Zero GC
jdk11新引入









